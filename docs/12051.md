# 序言切割

> 原文:[https://www.educba.com/prolog-cut/](https://www.educba.com/prolog-cut/)

![Prolog cut](../Images/f823ecc867814b2fa13540f102080f95.png)

<noscript><img class="alignnone size-full wp-image-503617" src="../Images/f823ecc867814b2fa13540f102080f95.png" alt="Prolog cut" width="900" height="500" srcset="https://cdn.educba.com/academy/wp-content/uploads/2022/04/Prolog-cut.jpg 900w, https://cdn.educba.com/academy/wp-content/uploads/2022/04/Prolog-cut-300x167.jpg 300w, https://cdn.educba.com/academy/wp-content/uploads/2022/04/Prolog-cut-768x427.jpg 768w" sizes="(max-width: 900px) 100vw, 900px" data-original-src="https://cdn.educba.com/academy/wp-content/uploads/2022/04/Prolog-cut.jpg"/></noscript>

## 序言切割简介

Prolog cut 是一个用 in 写成的目标！这总是会成功的，但不能走回头路。Prolog 中的 Cut 可以防止不必要的回溯，这包括在 Prolog 中寻找额外的解和避免不必要的计算。Prolog 中的这种切割应该谨慎使用，因为用户以实验的方式将切割插入到不按要求工作的代码中。如果用户这样做，并且当调试完成时，用户应该解释所使用的每个裁剪的需要和效果；因此，必须对序言部分进行注释。在这里，我们将通过几个例子来了解什么是切割以及如何使用切割。

**语法:**

<small>网页开发、编程语言、软件测试&其他</small>

下面是表示 cut 所需的语法，

**！**

例如，让我们考虑两个元素，并找出两者中的最大值。我将检查以下两个条件:

`If A > B, then Max := A
If A <= B, then Max:= B`

所以上面两个语句是互斥的，也就是说当其中一个条件为真时，另一个语句将自动为假。所以在这种情况下，我们可以使用 cut。

`max(A,B,A) := A >= B, !.
max(A,B,B) := A < B.
max_find(A,B,Max) := A >= B, !, Max = A; Max = B.`

在进入实际的例子之前，连同回溯。有几个例子看起来是一样的，但是通过回溯，不会按要求执行。

**样品 1:**

`max(A, B, A);-A>B.
max(A,B,B).`

这里我们从上到下搜索子句。因此，如果 A 小于或等于 B，第二个条款将适用。

`?- max(4,3,result).
result=4`

在上面的例子中，首先，两个参数值为 4 和 3，当用 4 和 3 测试上述规则时，结果如下。

所以现在，如果用户被迫返回，第二个子句必须被检查并产生一个错误的答案。

因此，为了在不想要的回溯的情况下得到完美的结果，我们使用 cut，用！.在规则的正文中，当切！在目标上第一次被执行，它就会成功。由于对上述示例的进一步评估总是会失败，因此减少了回溯来避免这种情况。

### 序言剪切示例

以下是延长切割的示例:

#### 示例#1

**Prolog cut 查找两个数字中的最大元素。**

`max(A, B, A) :- A>B, !.
max(A, B, B).
:- max(4, 1, R), writeln(R).`

**输出:**

![Prolog cut output 1](../Images/848ba06d1832a99e3eb762b8e241d443.png)

<noscript><img class="alignnone size-full wp-image-496132" src="../Images/848ba06d1832a99e3eb762b8e241d443.png" alt="Prolog cut output 1" width="498" height="51" srcset="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-1.png 498w, https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-1-300x31.png 300w" sizes="(max-width: 498px) 100vw, 498px" data-original-src="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-1.png"/></noscript>

#### 实施例 2

**Prolog 从 1 到给定整数的加法运算。**

`add(1, 1) :- !.
add(A, B) :- A1 is A-1, add(A1, B1),
B is B1+A.
:- add(10, R), writeln(R).`

**输出:**

![Prolog cut output 2](../Images/69607850ae3ca3e1f21893e8a08598f4.png)

<noscript><img class="alignnone size-full wp-image-496133" src="../Images/69607850ae3ca3e1f21893e8a08598f4.png" alt="Prolog cut output 2" width="505" height="53" srcset="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-2.png 505w, https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-2-300x31.png 300w" sizes="(max-width: 505px) 100vw, 505px" data-original-src="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-2.png"/></noscript>

#### 实施例 3

**Prolog cut 找出一个整数是负数、正数还是零。**

`integerType(0, zero) :- !.
integerType(A, negativeInteger) :- A<0, !.
integerType(A, positiveInteger).
:- integerType(-6, A), writeln(A).`

**输出:**

![output 3](../Images/7244a76cad3d0062c561b90a36ba2280.png)

<noscript><img class="alignnone wp-image-496134 size-full" src="../Images/7244a76cad3d0062c561b90a36ba2280.png" alt="output 3" width="517" height="55" srcset="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3.png 517w, https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3-300x32.png 300w" sizes="(max-width: 517px) 100vw, 517px" data-original-src="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3.png"/></noscript>

如果整数是正数，as，integerType(6，A)，writeln(A)。

![output 3.2](../Images/c4e4ee896b8b53b20dbe94cb0278c164.png)

<noscript><img class="alignnone wp-image-496135 size-full" src="../Images/c4e4ee896b8b53b20dbe94cb0278c164.png" alt="output 3.2" width="519" height="47" srcset="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3.2.png 519w, https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3.2-300x27.png 300w" sizes="(max-width: 519px) 100vw, 519px" data-original-src="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3.2.png"/></noscript>

如果 integer 为零，则为，integerType(0，A)，writeln(A)。

![output 3.3](../Images/31ff4f5d81929c57e8c729aa47481fc9.png)

<noscript><img class="alignnone wp-image-496136 size-full" src="../Images/31ff4f5d81929c57e8c729aa47481fc9.png" alt="output 3.3" width="519" height="56" srcset="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3.3.png 519w, https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3.3-300x32.png 300w" sizes="(max-width: 519px) 100vw, 519px" data-original-src="https://cdn.educba.com/academy/wp-content/uploads/2021/07/Prolog-cut-output-3.3.png"/></noscript>

序言切"！"总是马上成功；它有一个缺点。一旦语句被满足，程序将不允许回溯或回溯，并应用同一谓词的不同子句来满足目标。

*   当 cut 目标是当前目标时，它将成功，并且它的派生树被修剪掉其他选择，并且包括一个派生树，其中 cut 实际上是在目标序列中引入的。
*   !充当一个标记，prolog 不会超出这个标记。所有的切割选择都被设定和处理，就好像这些只是可能的方式。
*   如果用户在子句中移动得很远，不需要回溯并尝试另一种选择来证明目标，或者尝试另一种方法来满足为该目标证明的子目标，因为目标截切了“！”立即满足。
*   Prolog cut 可用于通过减少搜索空间来提高 Prolog 中的搜索效率。
*   序言剪切可用于删除不需要的答案。
*   Prolog cut 通常可用于告诉 Prolog，它已经为特定目标找到了正确的规则。它告诉 prolog 系统立即放弃一个特定的目标，甚至不去尝试任何替代的解决方案。
*   它将终止替代解决方案的生成。

切割可分为两种类型，即绿色切割和红色切割。

*   **绿切**:会影响程序的程序意义，但不影响声明意义。因此，它不影响程序的可读性，主要用于避免任何浪费的计算。
*   **红切**:影响程序的声明性意义和程序的过程性意义。它将影响程序的可读性，用于避免任何浪费的计算，并引入语义。如果不谨慎使用红色切割，它会以任意方式影响输出。

### 优点和缺点

*   Prolog 切割效率更高；解释器不会处理统一树中任何不必要的分支。
*   Prolog cut 将节省内存，即解释器不会为那些不统一的树节点分配空间。
*   序言剪切将产生副作用，改变回溯的方式。
*   它使得一些目标的位置标记不可访问。

### 结论

至此，我们将结束“序言切割”这一主题。我们已经看到了削减，它是如何实现的，以及背后的逻辑。我们也看到了它的语法“！”以及几个没有 cut 的回溯的例子，以及如何用 cut 来避免回溯。最后，我们还看到了 cut 的一些用途，并列出了 cut 的一些优点和缺点。谢谢！快乐学习！!

### 推荐文章

这是一个序言切割指南。这里我们讨论了 Prolog cut 的例子和用法，并列出了 cut 的一些优点和缺点。您也可以看看以下文章，了解更多信息–

1.  [Prolog 编程](https://www.educba.com/prolog-programming/)
2.  [Prolog 运算符](https://www.educba.com/prolog-operator/)
3.  [Prolog findall](https://www.educba.com/prolog-findall/)
4.  [XPath 节点](https://www.educba.com/xpath-nodes/)

<footer class="entry-footer">

<aside class="sidebar sidebar-primary widget-area" role="complementary" aria-label="Primary Sidebar">Primary Sidebar</aside>

</footer>