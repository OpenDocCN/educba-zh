# 层次聚类

> 原文:[https://www . edu CBA . com/hierarchical-clustering-agglomerate/](https://www.educba.com/hierarchical-clustering-agglomerative/)

![Hierarchical Clustering Agglomerative](../Images/a5a531b73a6b0b26a8ef438b006ee066.png)

<noscript><img class="alignnone size-full wp-image-442312" src="../Images/a5a531b73a6b0b26a8ef438b006ee066.png" alt="Hierarchical Clustering Agglomerative" width="900" height="500" srcset="https://cdn.educba.com/academy/wp-content/uploads/2020/12/Hierarchical-Clustering-Agglomerative.jpg 900w, https://cdn.educba.com/academy/wp-content/uploads/2020/12/Hierarchical-Clustering-Agglomerative-300x167.jpg 300w, https://cdn.educba.com/academy/wp-content/uploads/2020/12/Hierarchical-Clustering-Agglomerative-768x427.jpg 768w" sizes="(max-width: 900px) 100vw, 900px" data-original-src="https://cdn.educba.com/academy/wp-content/uploads/2020/12/Hierarchical-Clustering-Agglomerative.jpg"/></noscript>

## 层次聚类简介

凝聚聚类是各种层次聚类中最著名的一种，用于根据对象的相似性将对象聚集成簇。它也被称为 AGNES(凝聚巢)。计算开始时，将每个项目视为一个单独的束。接下来，组集合被逐渐收敛，直到所有的束被转换成包含所有文章的一个主要束。结果是基于树的文章描述，命名为树状图。在本主题中，我们将了解层次聚类聚合。

### 铝凝聚分层算法

第一步:在第一步中，我们计算出各个焦点的接近程度，并把所有六个信息焦点作为单独的组，如下图所示。

<small>Hadoop、数据科学、统计学&其他</small>

第二步:在第二阶段，可比较的束被合并并框定为一个单独的组。不如我们把 B，C，D，E 看作是在第二阶段收敛的比较组。目前，我们剩下四个组，它们是 A，BC，DE，f。

步骤 3:我们再次计算新群的接近度，并联合比较组来构造新群 A、BC、DEF。

步骤 4:计算新波束的邻域。束 DEF 和 BC 是可比较的，并且被合并以形成另一个组。我们现在只剩下两个束 A，BCDEF。

第五步:最后，每一个束都被合并和构建为一个单独的组。

可以通过利用树状图来想象层次聚类技术。

### 如何执行凝聚式分层？

对于这个集群，我们必须遵循几个步骤。

1.  为聚类分析准备数据。
2.  计算数据中任何对象对之间的所有信息都是相同的。
3.  现在，我们将使用链接函数，根据我们目前掌握的所有信息，将对象分类到一个层次聚类树中。
4.  现在，我们必须决定从集群中的何处切割树。这样，我们将创建树的一个分区

### 层次聚类凝聚技术

**数据集:**基于 R 语言的用户兴趣数据集

**第一步:**数据准备:

**第二步:**在数据中寻找相似性:

在选择哪些对象/束应该被连接或隔离的请求中，我们需要估计文章之间相似性的策略。

有许多技术来确定(不)相似性数据，包括欧几里得和曼哈顿分离。在 R 编程中，您可以利用 capacity dist()来处理信息索引中每对文章之间的分隔。这种计算的结果被称为分离或发散晶格。

当然，容量 dist()表示项目之间的欧氏距离；尽管如此，利用竞争技术显示不同的测量结果是可以想象的。看到了吗？dist 获取更多数据。

例如，考虑 R 基础信息索引 USArrests，您可以将分离网格表示为:

为了有效地查看文章之间的分离数据，我们将容量 dist()的结果重新格式化为利用 as 的网络。matrix()工作。在此网格中，由第 I 行 j 部分形成的单元格中的“尊重”表示第一个信息索引中文章 I 和项目 j 之间的分隔。例如，组件 1，1 表示项目 1 与其自身之间的分隔(为零)。组件 1，2 谈到了第 1 项和第 2 条之间的分离，等等。

下面的 R 代码展示了分离网格的最初 6 行和 6 段:

**第三步:**联动

链接容量获取由 capacity dist()返回的分离数据，并根据项目的接近程度将项目集合成束。接下来，这些最近被框住的束被连接起来形成更大的组。重复该过程，直到第一信息集合中的每一个项目都被连接到不同层次的树中。例如，给定由容量 dist()产生的分离框架“RES . dist ”, R 基本容量 hclust()可用于制作各种分级树。hclust()可以用作 pursue:有许多集群聚集技术(即链接策略)。下面描述了最广泛认可的链接策略。最大或完全连锁:两个簇之间的分离被表征为组 1 中的组分和簇 2 中的组分之间所有成对移除的最极端估计。它通常会产生逐渐减少的组。

*   最少或单一连锁:两组之间的分离被表征为簇 1 中的组分和簇 2 中的组分之间所有成对移除的基础估计。它通常会产生较长的“自由”组。
*   平均或正常连锁:两个束之间的分离被表征为组 1 中的组分和组 2 中的组分之间的正常分离。
*   质心连接:两个束之间的间隔被表征为组 1 的质心(长度 p 因子的平均向量)和组 2 的质心之间的间隔。

沃德的基本改变策略:它限制组内差异的总和。在每个进程中，具有最小组间间隔的一对束被合并。

注意，在聚类过程的每个阶段，具有最小连锁分离的两个组是相连的。

完全联动和沃德的策略是普遍喜欢的。

**第四步:**验证聚类树，切割树

将信息索引中的文章连接到渐进式分组树后，您应该检查树中的分色(即状态)是否精确地反映了第一个分色。

量化由 hclust()工作创建的束树如何反映您的信息的一种方法是，找出由 dist()工作产生的共生分离和第一分离信息之间的联系。如果聚类是合法的，则束树中的项目的连接应该与第一分离网络中的项目之间的分离具有稳固的关系。

关系系数的估计值越接近 1，聚类排列就越精确地反映了您的信息。0.75 以上的素质感觉很棒。“正常”连接策略似乎提供了这种测量的高估计值。这可能是它如此流行的一个解释。

R 基本容量协合()可用于计算渐进聚类的协合分离。

渐进式聚类的一个问题是，它没有告诉我们有多少个组，或者在哪里将树状图分割成帧束。

您可以按照给定的高度切割不同级别的树，以便将您的信息分成不同的组。R base capacity cutree()可用于将 hclust()创建的树切割成几个集合，方法是确定集合的理想数量或切割高度。它恢复包含每个感知的组号的向量。

**优势**

1.不需要关于需要多少个集群的信息。

2.易于使用和实施

**缺点**

1.在这个算法中我们不能后退一步。

2.时间复杂度更高至少 0(n^2logn)

### 结论

渐进式聚类是一种聚类检查策略，它产生基于树的信息描述(即:树状图)。树状图中的文章是基于它们的相似性来连接的。要在 R 中执行渐进式束检查，第一步是利用容量 dist()来确定成对分离框架。接下来，hclust()容量利用这一计算的结果来创建各种分级树。最后，您可以利用 fviz _ dend()[在 factoextra R 包中]的功能有效地绘制一个优秀的树状图。同样可以设想将树砍成给定的高度，以便将信息分配到多个集合中(R work cutree())。

### 推荐文章

这是一个聚集层次聚类的指南。在这里，我们讨论如何执行凝聚层次以及技术。您也可以看看以下文章，了解更多信息–

1.  [层次聚类算法](https://www.educba.com/hierarchical-clustering-algorithm/)
2.  [层次数据库模型](https://www.educba.com/hierarchical-database-model/)
3.  [系统聚类分析](https://www.educba.com/hierarchical-clustering-analysis/)
4.  [R 中的层次聚类](https://www.educba.com/hierarchical-clustering-in-r/)

<footer class="entry-footer">

<aside class="sidebar sidebar-primary widget-area" role="complementary" aria-label="Primary Sidebar">Primary Sidebar</aside>

</footer>